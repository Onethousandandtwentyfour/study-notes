# 前端模块化-笔记

### 1.什么是模块化



### 2.为什么要使用模块化



### 3.基础示例

```js
//ES5基础示例
//A.js
;
var moduleA = (function(){
	var name='a';
	var type='js';
	return {
		name:name,
		type:type,
	}
})();
//B.js
;
var moduleB = (function(){
	console.log(moduleA.name);//'a'
})();
```

### 4.常见模块化规范

模块化的核心是 **导出** 和 **导入**

##### 1.CommonJs

```js
#语法
导出：module.exports = {...};
导入：require('path');
```

##### 2.AMD

##### 3.Cmd

##### 4.ES6的modules

```js
#语法
导出：
	方式一：export {}
	方式二：export let|const|var|function|class name ...;
    方式三：export default name;
#export default导出的变量，在import时可以自定义名称，但是一个文件内只能使用一个export default;
#export {}导出的变量不能用 import selfName from 'path'导入;
#统一全部导入 import * as selfName from 'path';
导入：import [name] from 'path';
...
在ES6中使用var声明变量时，不会再出现命名冲突。
因为在ES6中导入js文件时，type为module,模块化导入，会创建单独的作用域，各个文件之间的作用域就不会有冲突。
```

# webpack-前端模块化打包工具

### 1.认识webpack

官方解释：webpack是一个现代的JavaScript应用的**模块打包**工具

官网：webpack.js.org

### 2.和grunt|gulp的对比

1. grunt|gulp的核心是Task
   - 先配置一系列的Task,例如ES6,ts转化，图片压缩，scss转成css;
   - 之后通过g依次执行Task,让整个流程自动化;
   - 所以g也被称为前端自动化任务管理工具;
2. 什么时候用grunt|gulp
   - 工程模块比较简单，没有用到模块化的概念
   - 只需要进行简单的合并，压缩
3. 不同点
   - grunt|gulp强调的是前端流程的自动化，模块化不是它的核心
   - webpack强调模块化开发管理，文件压缩合并，预处理等只是附加功能；

### 3.安装&使用

###### 1.webpack依赖node环境,node包含各种包，node使用npm（node package manager)管理这些包；

###### 2.安装&使用

- 全局安装webpack  npm i webpack@3.6.0 -g
- 本地安装webpack  npm i webpack@3.6.0 --save-dev  开发时依赖
- 只要在在终端执行webpack命令，都是用的全局的webpack的包，如果要用本地的webpack，需要在package.json中scripts字段中配置对应命令，package.json中的scripts中的脚本在执行时，会先寻找本地node_modules中对应的包，这里是node_modules/.bin/webpack，当node在本地找不到webpack的包时，才会去找全局的包。

```js
3.6.0对应vue-cli 2.x依赖的版本
打包命令：
	webpack  ./src/source.js  ./dist/target.js
	#source.js内可以引入其他模块，webpack会处理依赖关系;
```

	###### 3.入口和出口  =》 自定义命令 =》 新建配置文件 webpack.config.js =》直接使用webpack命令打包

```js
//webpack.config.js 示例
{
	entry:'./src/source.js',//入口
	output:{//出口
        #path 需要绝对路径,通过node提供的path包来获取路径
        #__dirname是node上下文中自带的变量，存储当前项目的绝对路径
        #resolve 拼接两个路径
        path:require('path').resolve(__dirname,'dist'),
        filename:'target.js';//打包后的文件名称
    }
}

#如果需要使用node相关的包，需要执行npm init命令，然后根据提示写入配置信息，最终会生成package.json文件
//package.json 示例
{
  "name": "learn-webpack-v1",
  "version": "1.0.0",
  "description": "lalala",
  "main": "main.js",
  "scripts": {//自定义指令
    "test": "echo \"Error: no test specified\" && exit 1",
     "build":"webpack",//先在本地找webpack，找不到才会去全局找
  },
  "author": "csh",
  "license": "ISC"
}
```

###### 4.loader

​	作用：webpack处理js,但对于less转成css,es6转es5等等都是不支持的，所以需要对应的loader扩展。

###### 1.css-loader&style-loader

1.1先安装 **npm install --save-dev css-loader**，**npm install --save-dev style-loader**

css-loader 只负责加载.css文件，style-loader负责解析并将样式添加到dom上。

1.2在webpack.config.js的module字段中配置使用规则;

```js
module:{
    rules:[
		{
        	test:/\.css$/,
        	use:['style-loader','css-loader'],//使用多个loader时，从右向左读
    	}
	]
}
//this.getResolve is not a function 是需要调低 css-loader和style-loader的版本
//对应webpack3.6.0  css-loader为3.3.0  style-loader为1.0.0
```







